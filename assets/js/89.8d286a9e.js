(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{378:function(s,t,a){"use strict";a.r(t);var e=a(10),o=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"react系列之6-hooks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react系列之6-hooks"}},[s._v("#")]),s._v(" React系列之6-hooks")]),s._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),t("p",[s._v("class组件存在问题：")]),s._v(" "),t("ul",[t("li",[s._v("大型项目很难拆分和重构，很难测试（即class不易拆分）")]),s._v(" "),t("li",[s._v("相同的业务逻辑，分散到各个方法中，逻辑混乱（ajax请求、绑定/解绑）")]),s._v(" "),t("li",[s._v("复用逻辑变的复杂，如Mixins、HOC、Render Props")])]),s._v(" "),t("p",[s._v("React组件更易用函数表达：")]),s._v(" "),t("ul",[t("li",[s._v("React提倡函数式编程，view=fn(props)")]),s._v(" "),t("li",[s._v("函数更灵活，更易拆分，更易测试")]),s._v(" "),t("li",[s._v("但函数组件太简单，需要增强能力 — —Hooks")])]),s._v(" "),t("p",[s._v("本章主要内容：")]),s._v(" "),t("ul",[t("li",[s._v("State Hooks")]),s._v(" "),t("li",[s._v("Effect Hooks")]),s._v(" "),t("li",[s._v("其他 Hooks")]),s._v(" "),t("li",[s._v("自定义 Hooks")]),s._v(" "),t("li",[s._v("组件逻辑复用（Hooks的意义）")]),s._v(" "),t("li",[s._v("规范和注意事项")])]),s._v(" "),t("h2",{attrs:{id:"一、state-hooks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、state-hooks"}},[s._v("#")]),s._v(" 一、State Hooks")]),s._v(" "),t("h2",{attrs:{id:"二、effect-hooks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、effect-hooks"}},[s._v("#")]),s._v(" 二、Effect Hooks")]),s._v(" "),t("p",[s._v("目的：让函数组件模拟生命周期")]),s._v(" "),t("ul",[t("li",[s._v("默认函数组件没有生命周期")]),s._v(" "),t("li",[s._v("函数组件是一个纯函数，执行完即销毁，自己无法实现生命周期")]),s._v(" "),t("li",[s._v("使用 EffectHooks 把生命周期 “钩” 到纯函数中")])]),s._v(" "),t("p",[s._v("useEffect 使用总结")]),s._v(" "),t("ul",[t("li",[s._v("模拟 componentDidMount - useEffect 依赖 []")]),s._v(" "),t("li",[s._v("模拟 componentDidUpdate - useEffect 无依赖，或者依赖[a,b]")]),s._v(" "),t("li",[s._v("模拟 componentWillUmMount - useEffect 中返回一个函数")])]),s._v(" "),t("p",[s._v("useEffect 让纯函数有了副作用")]),s._v(" "),t("ul",[t("li",[s._v("如设置全局定时任务")])]),s._v(" "),t("p",[s._v("小结")]),s._v(" "),t("ul",[t("li",[s._v("函数组件更适合React组件，但需要 Hooks 增强功能")]),s._v(" "),t("li",[s._v("useState 可实现 state 和 setState")]),s._v(" "),t("li",[s._v("useEffect 可模拟组件主要的生命周期")])]),s._v(" "),t("h2",{attrs:{id:"三、其他hooks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、其他hooks"}},[s._v("#")]),s._v(" 三、其他hooks")]),s._v(" "),t("h3",{attrs:{id:"usereducer能代替reduce吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#usereducer能代替reduce吗"}},[s._v("#")]),s._v(" useReducer能代替reduce吗")]),s._v(" "),t("ul",[t("li",[s._v("useReducer 是 useState 的代替方案，用于state复杂变化")]),s._v(" "),t("li",[s._v("useReducer 是单个组件状态管理，组件通讯还需要props")]),s._v(" "),t("li",[s._v("redux 是全局的状态管理，多组件共享数据")])]),s._v(" "),t("h3",{attrs:{id:"usememo使用总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#usememo使用总结"}},[s._v("#")]),s._v(" useMemo使用总结")]),s._v(" "),t("ul",[t("li",[s._v("React默认会更新所有子组件")]),s._v(" "),t("li",[s._v("Class组件使用SCU和PureComponent做优化")]),s._v(" "),t("li",[s._v("Hooks中使用useMemo，但优化原理是相同的")])]),s._v(" "),t("h3",{attrs:{id:"usecallback使用总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#usecallback使用总结"}},[s._v("#")]),s._v(" useCallback使用总结")]),s._v(" "),t("ul",[t("li",[s._v("useMemo用来缓存数据")]),s._v(" "),t("li",[s._v("useCallback用来缓存函数")])]),s._v(" "),t("h2",{attrs:{id:"四、自定义hook"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、自定义hook"}},[s._v("#")]),s._v(" 四、自定义hook")]),s._v(" "),t("ul",[t("li",[s._v("本质是一个函数，以use开头")]),s._v(" "),t("li",[s._v("内部正常使用 useState useEffect 获取其他Hooks")]),s._v(" "),t("li",[s._v("自定义返回结果，格式不限")])]),s._v(" "),t("h3",{attrs:{id:"第三方hook"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三方hook"}},[s._v("#")]),s._v(" 第三方hook")]),s._v(" "),t("p",[s._v("todo...")]),s._v(" "),t("h2",{attrs:{id:"五、hooks使用规范"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、hooks使用规范"}},[s._v("#")]),s._v(" 五、Hooks使用规范")]),s._v(" "),t("ul",[t("li",[s._v("只能用于React函数组件和自定义Hook中，其他地方不可以")]),s._v(" "),t("li",[s._v("只能用于顶层代码，不能在循环、判断中使用Hooks")]),s._v(" "),t("li",[s._v("eslint插件eslint-plugin-react-hooks可以帮到你")])]),s._v(" "),t("h3",{attrs:{id:"hooks调用顺序必须保持一致"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hooks调用顺序必须保持一致"}},[s._v("#")]),s._v(" Hooks调用顺序必须保持一致")]),s._v(" "),t("ul",[t("li",[s._v("无论是render还是re-render，Hooks调用顺序必须保持一致")]),s._v(" "),t("li",[s._v("如果Hooks出现在循环、判断里，则无法保证顺序一致")]),s._v(" "),t("li",[s._v("Hooks严重依赖于调用顺序！重要！")])]),s._v(" "),t("h3",{attrs:{id:"class做组件逻辑复用的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class做组件逻辑复用的问题"}},[s._v("#")]),s._v(" class做组件逻辑复用的问题")]),s._v(" "),t("h3",{attrs:{id:"hooks做组件逻辑复用的好处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hooks做组件逻辑复用的好处"}},[s._v("#")]),s._v(" Hooks做组件逻辑复用的好处")]),s._v(" "),t("ul",[t("li",[s._v("完全符合Hook是原有规则，没有其他要求，易于理解记忆")]),s._v(" "),t("li",[s._v("变量作用域很明确")]),s._v(" "),t("li",[s._v("不会产生组件嵌套")])]),s._v(" "),t("h2",{attrs:{id:"六、react-hooks注意事项-哪些坑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、react-hooks注意事项-哪些坑"}},[s._v("#")]),s._v(" 六、React Hooks注意事项（哪些坑）")]),s._v(" "),t("ul",[t("li",[s._v("useState初始化state值，只有第一次有效（修改state需要通过setState修改，不能通过props来修改state的值）")]),s._v(" "),t("li",[s._v("useEffect内部不能修改state（依赖为空[]时不会执行）")]),s._v(" "),t("li",[s._v("useEffect可能出现死循环（依赖里不能有对象或数组）")])]),s._v(" "),t("h2",{attrs:{id:"问题解答-自检"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#问题解答-自检"}},[s._v("#")]),s._v(" 问题解答（自检）")]),s._v(" "),t("h4",{attrs:{id:"_1、为什么要使用hooks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、为什么要使用hooks"}},[s._v("#")]),s._v(" 1、为什么要使用Hooks？")]),s._v(" "),t("ul",[t("li",[s._v("完善函数组件的能力，函数更适合React组件\n"),t("ul",[t("li",[s._v("class组件中，相同的逻辑散落在各处")]),s._v(" "),t("li",[s._v("DidMount和Didupdate")])])])]),s._v(" "),t("h4",{attrs:{id:"_2、react-hooks如何模拟组件生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、react-hooks如何模拟组件生命周期"}},[s._v("#")]),s._v(" 2、react Hooks如何模拟组件生命周期？")]),s._v(" "),t("h4",{attrs:{id:"_3、如何自定义hook"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、如何自定义hook"}},[s._v("#")]),s._v(" 3、如何自定义Hook")]),s._v(" "),t("h4",{attrs:{id:"_4、hooks性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、hooks性能优化"}},[s._v("#")]),s._v(" 4、Hooks性能优化")]),s._v(" "),t("h4",{attrs:{id:"_5、使用hooks遇到哪些坑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、使用hooks遇到哪些坑"}},[s._v("#")]),s._v(" 5、使用Hooks遇到哪些坑")]),s._v(" "),t("h4",{attrs:{id:"_6、hooks相比hoc和props-render有哪些优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、hooks相比hoc和props-render有哪些优点"}},[s._v("#")]),s._v(" 6、Hooks相比HOC和props render有哪些优点")]),s._v(" "),t("h2",{attrs:{id:"我的疑问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我的疑问"}},[s._v("#")]),s._v(" 我的疑问")]),s._v(" "),t("h3",{attrs:{id:"如何看待hooks的作用-功能增强-和现有的功能如vue-computed对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何看待hooks的作用-功能增强-和现有的功能如vue-computed对比"}},[s._v("#")]),s._v(" 如何看待hooks的作用？功能增强？和现有的功能如vue computed对比？")]),s._v(" "),t("h3",{attrs:{id:"不同hooks之间的关系-如-useeffect和userefs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不同hooks之间的关系-如-useeffect和userefs"}},[s._v("#")]),s._v(" 不同hooks之间的关系？如 useEffect和useRefs")]),s._v(" "),t("h3",{attrs:{id:"带hooks的函数组件渲染和更新是怎么个逻辑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#带hooks的函数组件渲染和更新是怎么个逻辑"}},[s._v("#")]),s._v(" 带hooks的函数组件渲染和更新是怎么个逻辑？")]),s._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),t("h2",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[s._v("#")]),s._v(" 参考资料")])])}),[],!1,null,null,null);t.default=o.exports}}]);