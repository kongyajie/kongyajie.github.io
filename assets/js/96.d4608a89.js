(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{386:function(v,_,t){"use strict";t.r(_);var e=t(10),i=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"vue系列之6-vue3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue系列之6-vue3"}},[v._v("#")]),v._v(" Vue系列之6-Vue3")]),v._v(" "),_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),_("p",[v._v("本章主要内容：")]),v._v(" "),_("ul",[_("li",[v._v("新功能")]),v._v(" "),_("li",[v._v("原理")]),v._v(" "),_("li",[v._v("vite")])]),v._v(" "),_("h3",{attrs:{id:"vue3比vue2有什么优势-重点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3比vue2有什么优势-重点"}},[v._v("#")]),v._v(" Vue3比Vue2有什么优势？（重点）")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("性能更好")])]),v._v(" "),_("li",[v._v("体积更小")]),v._v(" "),_("li",[_("strong",[v._v("更好的TS支持")])]),v._v(" "),_("li",[_("strong",[v._v("更好的代码组织&逻辑抽离")])]),v._v(" "),_("li",[v._v("更多新功能")])]),v._v(" "),_("h3",{attrs:{id:"vue3和vue2生命周期有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3和vue2生命周期有什么区别"}},[v._v("#")]),v._v(" Vue3和Vue2生命周期有什么区别？")]),v._v(" "),_("p",[v._v("Options API声明周期")]),v._v(" "),_("ul",[_("li",[v._v("beforeDestory => beforeUnmount")]),v._v(" "),_("li",[v._v("destoryed => unmounted")])]),v._v(" "),_("h3",{attrs:{id:"如何理解composition-api和options-api-重要"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何理解composition-api和options-api-重要"}},[v._v("#")]),v._v(" 如何理解Composition API和Options API（重要）")]),v._v(" "),_("p",[v._v("CompositionAPI带来了什么")]),v._v(" "),_("ul",[_("li",[v._v("更好的代码组织")]),v._v(" "),_("li",[v._v("更好的逻辑复用")]),v._v(" "),_("li",[v._v("更好的类型推导")])]),v._v(" "),_("p",[v._v("如何选择")]),v._v(" "),_("ul",[_("li",[v._v("不建议共用，会引起混乱")]),v._v(" "),_("li",[v._v("小型项目、业务逻辑简单，用Options API")]),v._v(" "),_("li",[v._v("中大型项目、逻辑复杂，用Composition API")])]),v._v(" "),_("h3",{attrs:{id:"如何理解ref-toref和torefs"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何理解ref-toref和torefs"}},[v._v("#")]),v._v(" 如何理解ref toRef和toRefs")]),v._v(" "),_("p",[v._v("ref")]),v._v(" "),_("ul",[_("li",[v._v("生成值类型的响应式数据")]),v._v(" "),_("li",[v._v("可用于模板和reactive")]),v._v(" "),_("li",[v._v("通过.value修改值")])]),v._v(" "),_("p",[v._v("最佳使用方式")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("用reactive做对象的响应式，用ref做值类型的响应式")])]),v._v(" "),_("li",[v._v("setup中返回toRefs(state)，或者toRef(state,'xxx')")]),v._v(" "),_("li",[v._v("ref的变量命名都用xxxRef")]),v._v(" "),_("li",[v._v("合成函数返回响应式对象时，使用toRefs")])]),v._v(" "),_("p",[v._v("为何需要ref？")]),v._v(" "),_("ul",[_("li",[v._v("返回值类型，会丢失响应式")]),v._v(" "),_("li",[v._v("如在setup、computed、合成函数，都有可能返回值类型")]),v._v(" "),_("li",[v._v("Vue如不定义ref，用户将自造ref，反而混乱")])]),v._v(" "),_("p",[v._v("为何需要.value?")]),v._v(" "),_("ul",[_("li",[v._v("ref是一个对象（不丢失响应式），value存储值")]),v._v(" "),_("li",[v._v("通过.value属性的get和set实现响应式")]),v._v(" "),_("li",[v._v("用于模板、Reactive时，不需要.value，其他情况都需要")])]),v._v(" "),_("p",[v._v("为何需要toRef和toRefs？")]),v._v(" "),_("ul",[_("li",[v._v("初衷：不丢失响应式的情况下，把对象数据"),_("strong",[v._v("分解/解构")])]),v._v(" "),_("li",[v._v("前提：针对的是响应式对象（reative封装的）非普通对象")]),v._v(" "),_("li",[v._v("注意："),_("strong",[v._v("不创造")]),v._v("响应式，而是"),_("strong",[v._v("延续")]),v._v("响应式")])]),v._v(" "),_("blockquote",[_("p",[v._v("reactive/ref创建响应式，toRef/toRefs延续响应式")])]),v._v(" "),_("h3",{attrs:{id:"vue3升级了哪些重要功能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3升级了哪些重要功能"}},[v._v("#")]),v._v(" Vue3升级了哪些重要功能")]),v._v(" "),_("ul",[_("li",[v._v("createApp")]),v._v(" "),_("li",[v._v("emits属性")]),v._v(" "),_("li",[v._v("生命周期")]),v._v(" "),_("li",[v._v("多事件")]),v._v(" "),_("li",[v._v("Fragment")]),v._v(" "),_("li",[v._v("移除.sync")]),v._v(" "),_("li",[v._v("异步组件写法")]),v._v(" "),_("li",[v._v("移除filter")]),v._v(" "),_("li",[v._v("Teleport")]),v._v(" "),_("li",[v._v("Supense")]),v._v(" "),_("li",[v._v("Composition API")])]),v._v(" "),_("h3",{attrs:{id:"composition-api-实现逻辑复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#composition-api-实现逻辑复用"}},[v._v("#")]),v._v(" Composition API 实现逻辑复用")]),v._v(" "),_("ul",[_("li",[v._v("抽离逻辑代码到一个函数")]),v._v(" "),_("li",[v._v("函数命名约定为 useXxxx 格式（React Hooks也是）")]),v._v(" "),_("li",[v._v("在 setup 中引用 useXxxx 函数")])]),v._v(" "),_("h3",{attrs:{id:"vue3如何实现响应式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3如何实现响应式"}},[v._v("#")]),v._v(" Vue3如何实现响应式")]),v._v(" "),_("ul",[_("li",[v._v("回顾vue2.x的Object.defineProperty")]),v._v(" "),_("li",[v._v("学习Proxy语法")]),v._v(" "),_("li",[v._v("Vue3如何用Proxy实现响应式")])]),v._v(" "),_("p",[v._v("Object.definePropery的缺点：")]),v._v(" "),_("ul",[_("li",[v._v("深度监听需要一次性递归")]),v._v(" "),_("li",[v._v("无法监听新增属性/删除属性（vue.set Vue.delete)")]),v._v(" "),_("li",[v._v("无法原生监听数组，需要特殊处理")])]),v._v(" "),_("p",[v._v("Proxy实现响应式")]),v._v(" "),_("ul",[_("li",[v._v("基本使用")]),v._v(" "),_("li",[v._v("Reflect")]),v._v(" "),_("li",[v._v("实现响应式")])]),v._v(" "),_("p",[v._v("Reflect作用")]),v._v(" "),_("ul",[_("li",[v._v("和Proxy能力一一对应")]),v._v(" "),_("li",[v._v("规范化、标准化、函数化")]),v._v(" "),_("li",[v._v("代替Object上的工具函数（防止Object大而全，会更纯净）")])]),v._v(" "),_("p",[v._v("Vue3用Proxy实现响应式")]),v._v(" "),_("ul",[_("li",[v._v("深度监听，性能更好")]),v._v(" "),_("li",[v._v("可监听新增/删除属性")]),v._v(" "),_("li",[v._v("可监听数组变化")]),v._v(" "),_("li",[v._v("Proxy无法兼容所有浏览器，无法polyfill")])]),v._v(" "),_("h3",{attrs:{id:"watch和watcheffect的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#watch和watcheffect的区别"}},[v._v("#")]),v._v(" watch和watchEffect的区别")]),v._v(" "),_("ul",[_("li",[v._v("两者都可监听data属性变化")]),v._v(" "),_("li",[v._v("watch需要明确监听哪个属性")]),v._v(" "),_("li",[v._v("watchEffect会根据其中的属性，自动监听其变化")])]),v._v(" "),_("h3",{attrs:{id:"setup中如何获取组件实例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#setup中如何获取组件实例"}},[v._v("#")]),v._v(" setup中如何获取组件实例")]),v._v(" "),_("ul",[_("li",[v._v("在setup和其他composition API中没有this")]),v._v(" "),_("li",[v._v("可通过getCurrentInstance获取当前实例")]),v._v(" "),_("li",[v._v("若使用Options API可正常获取this")])]),v._v(" "),_("h3",{attrs:{id:"vue3为什么比vue2快-重要"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3为什么比vue2快-重要"}},[v._v("#")]),v._v(" Vue3为什么比Vue2快（重要）")]),v._v(" "),_("ul",[_("li",[v._v("Proxy响应式")]),v._v(" "),_("li",[v._v("PatchFlag 静态比较")]),v._v(" "),_("li",[v._v("hoistStatic 静态提升")]),v._v(" "),_("li",[v._v("CacheHandler 缓存事件")]),v._v(" "),_("li",[v._v("SSR优化")]),v._v(" "),_("li",[v._v("Tree-Shaking优化")])]),v._v(" "),_("p",[v._v("PatchFlag")]),v._v(" "),_("ul",[_("li",[v._v("编译模板时，动态节点做标记")]),v._v(" "),_("li",[v._v("标记，分为不同的类型，如Text、Props")]),v._v(" "),_("li",[v._v("diff算法时，可以区分静态节点，以及不同类型的动态节点")])]),v._v(" "),_("p",[v._v("hoistStatic")]),v._v(" "),_("ul",[_("li",[v._v("将静态节点的定义，提升到父作用域，缓存起来")]),v._v(" "),_("li",[v._v("多个相邻的静态节点，会被合并起来")]),v._v(" "),_("li",[v._v("典型的拿空间换时间的优化策略")])]),v._v(" "),_("p",[v._v("SSR优化")]),v._v(" "),_("ul",[_("li",[v._v("静态节点输出，绕过Vdom")]),v._v(" "),_("li",[v._v("动态节点，还是需要动态渲染")])]),v._v(" "),_("p",[v._v("Vite为什么这么快")]),v._v(" "),_("ul",[_("li",[v._v("开发环境下使用ES6 Module，无需打包——非常快")]),v._v(" "),_("li",[v._v("生产环境使用rollup，并不会快很多")]),v._v(" "),_("li",[v._v("ES6 Module兼容性目前大部分浏览器都支持，未来几年很可能生产环境也可以使用")])]),v._v(" "),_("h3",{attrs:{id:"composition-api和react-hooks对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#composition-api和react-hooks对比"}},[v._v("#")]),v._v(" Composition API和React Hooks对比")]),v._v(" "),_("ul",[_("li",[v._v("前者setup只会被调用一次，而后者函数会被多次调用")]),v._v(" "),_("li",[v._v("前者无需useMemo、useCallback，因为setup只调用一次")]),v._v(" "),_("li",[v._v("前者无需顾虑调用顺序，而后者需要保证hooks的顺序一致")]),v._v(" "),_("li",[v._v("前者reactive和ref比后者useState，要难理解")])])])}),[],!1,null,null,null);_.default=i.exports}}]);